<!-- rmarkdown v1 -->
---
output: 
  github_document:
    toc: true
---

<!-- README.md is generated from README.Rmd. Please edit that file -->
```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```


# Runner
[![Travis-CI Build Status](https://travis-ci.org/gogonzo/runner.svg?branch=master)](https://travis-ci.org/gogonzo/runner)
[![Project Status](http://www.repostatus.org/badges/latest/active.svg)](http://www.repostatus.org/#active)
[![MIT License](https://badges.frapsoft.com/os/mit/mit.svg)](https://opensource.org/licenses/mit-license.php)
[![Coverage status](https://codecov.io/gh/gogonzo/runner/branch/master/graph/badge.svg)](https://codecov.io/github/gogonzo/runner?branch=master)

Running functions for R vector written in Rcpp

## Installation

You can install runner from github with:

```{r gh-installation, eval=FALSE, include=FALSE}
# install.packages("devtools")
devtools::install_github("gogonzo/runner")
```

## Examples
The main idea of the package is to provide running operations on R vectors. Running functions are these which are applied to all elements up to actual one. For example implemented already in `base` `cumsum`, `cummin` etc. Functions provided in this package works similar but with extended functionality such as handling `NA` and custom window size. Most functions provided in package are based on the same logic  
1. `k` window size denotes number of elements from i-th backwards, where functions are calculated.  
(obrazek pokazujÄ…cy ruchome okno)
2. `na_rm` handling missing equivalent to `na.rm`. In case of running functions, `NA` is replaced with last finite value.  
3. `na_pad` if window size exceeds number of available elements, than first `k-1` are filled with `NA`.  
4. `which` In case of running index, which value ('first' or 'last')

### Creating windows
Function creates list of windows. Because `runner` provide limited functionality, one can create running-window-list which can be further computed to obtain desired statistic (eg. window sum). `x` is a vector to be 'windowed' and `k` is a length of window. In this example window length is varying as specified by `k`. Provide one value to obtain constant window size.

```{r run_window, echo=TRUE}
library(runner)
library(magrittr)
set.seed(11)

x1 <- 1:5
k <- c(1,2,3,3,2)

window_run( x=x, k = k )
```

Such windows can be used in further calculations, with any R function. Example below shows how to obtain running `sum` in specified, varying window length (specified by `k`).

```{r run_window2, echo=TRUE}
window_run( x=x1, k = k ) %>%
  lapply(sum) %>%
  unlist
```
### Unique elements in window
One 
```{r unique_run, echo=TRUE}
x2 <- sample( letters[1:3], 6, replace=TRUE)
x2
unique_run( x=x2, k = 3 )
```

### Running aggregations

Runner provides basic aggregation method calculated within running windows. By default missing values are removed before calculations (`na_rm=TRUE`). 

```{r generate example, echo=TRUE}
set.seed(11)
x <- rnorm( 30 ) %>% cumsum
x[c(5,6,10,11)] <- NA

k  <- sample( 2:5, 30, replace=TRUE)
```


#### min_run
```{r min_run_example, echo=TRUE}
min1 <- min_run(x)
min2 <- min_run(x, k=4)
min3 <- min_run(x, k=k, na_rm = FALSE)
```

```{r plot_min_run, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

library(ggplot2);library(ggrepel); library(gridExtra)
plot <- 
  data.frame(i = 1:30) %>%
  ggplot(aes(x=i)) +
  geom_line(aes( y = fill_run(x)) ) +
  geom_point(aes( y = fill_run(x)) ) +
  geom_point(aes(y = min_run(x)), color="red", shape=3) +
  ggtitle("running minimum")
  

plot1 <- 
  data.frame(i = 1:30) %>%
  ggplot(aes(x=i)) +
  geom_line(aes( y = x)) +
  geom_point(aes( y = x)) +
  geom_point(aes(y = min1), color="red", shape=3) +
  ggtitle("running minimum handling NA")
  
plot2 <- 
  data.frame(i = 1:30) %>%
  ggplot(aes(x=i)) +
  geom_line(aes( y = x)) +
  geom_point(aes( y = x)) +
  geom_point(aes(y = min2), color="red", shape=3) +
  ggtitle("running minimum with window k=4")
  
plot3 <- 
  data.frame(i = 1:30) %>%
  ggplot(aes(x=i)) +
  geom_line(aes( y = x)) +
  geom_point(aes(y = min3), color="red", shape=3) +
  geom_label(aes(label=k, y=fill_run(x)+0.5), size=2) + 
  ggtitle("running minimum with varying k")


multiplot(plot, plot2,plot1,plot3, cols = 2)  
  
```

```

#### max_run
```{r max_run_example, echo=TRUE}
max1 <- max_run(x)
max2 <- max_run(x, k=4)
max3 <- max_run(x, k=k, na_rm = FALSE)
```

#### mean_run
```{r mean_run_example, echo=TRUE}
mean1 <- mean_run(x)
mean2 <- mean_run(x, k=4)
mean3 <- mean_run(x, k=k, na_rm = FALSE)
```

#### sum_run
```{r sum_run_example, echo=TRUE}
sum1 <- sum_run(x)
sum2 <- sum_run(x, k=4)
sum3 <- sum_run(x, k=k, na_rm = FALSE)
```





### Running indexes

